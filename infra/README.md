# Инфраструктура: Docker + Compose

В каталоге `infra/` собраны все артефакты, необходимые чтобы развернуть стек «PostgreSQL + CV-приложение» одним запуском. Стек максимально приближен к локальной разработке: код монтируется в контейнер и выполняется прямо из примапленной директории, поэтому любые изменения видны без пересборки образа.

## Состав директории

| Файл | Назначение |
| ---- | ---------- |
| `Dockerfile` | Python 3.11 + системные пакеты (ffmpeg, Tesseract, OpenCV-зависимости). Код раскладывается в `/workspace`, который позже можно монтировать из хоста. |
| `entrypoint.sh` | Финальный запуск: ждёт доступность PostgreSQL, вызывает `app.db_app.create_tables()`, после чего стартует `python app/run_app.py --mode ${APP_MODE}`. Подхватывает `APP_ROOT`, поэтому точка входа остаётся рабочей даже при bind mount. |
| `docker-compose.yml` | Два сервиса: `postgres` (официальный образ 16 версии) и `cv-app` (наш Dockerfile). В контейнер монтируется весь репозиторий (`..:/workspace`), поэтому код, данные и модели доступны мгновенно. |
| `.env.example` | Заготовка переменных окружения. Скопируйте в `.env`, если хотите менять параметры без правки compose-файла. |

## Быстрый старт

```bash
cp infra/.env.example infra/.env   # по желанию, чтобы переопределить переменные
docker compose -f infra/docker-compose.yml up --build
```

После сборки:
- `postgres` поднимается с volume `postgres_data`.
- `cv-app` устанавливает зависимости, ждёт БД, создаёт таблицы и запускает `run_app.py` в режиме `all`.
- Gradio-дешборд будет доступен на `http://localhost:7860` (порт задаётся переменной `APP_HTTP_PORT`).

Остановить стек:

```bash
docker compose -f infra/docker-compose.yml down        # сервисы
docker compose -f infra/docker-compose.yml down -v     # сервисы + volume PostgreSQL
```

## Переменные окружения

Все параметры можно задать в `infra/.env` (compose автоматически подхватит файл) или прямо в окружении:

- `POSTGRES_DB`, `POSTGRES_USER`, `POSTGRES_PASSWORD` — настройки БД.
- `DATABASE_URL` — строка подключения, которую использует приложение (`postgresql+asyncpg://...`).
- `APP_MODE` — аргумент для `run_app.py` (`all`, `pipeline`, `dashboard`).
- `APP_HTTP_PORT` — внешний порт Gradio (`7860` по умолчанию).
- `SKIP_DB_BOOTSTRAP` — если `1`, контейнер не будет создавать таблицы (актуально при использовании сторонней БД).
- `APP_ROOT` — путь, из которого выполняется код внутри контейнера. По умолчанию `/workspace`; при запуске через compose он уже примаплен к корню проекта.

## Примапленный код и данные

Compose монтирует корень репозитория в `/workspace`, поэтому внутри контейнера доступны все папки проекта:

```
.. (корень проекта на хосте) -> /workspace (в контейнере)
```

Это даёт несколько плюсов:

- Любые правки в коде (`app/`, `infra/` и т.д.) видны контейнеру без пересборки.
- Пайплайн использует реальные данные из `data/`, а результаты (`data/output`) остаются на хосте.
- Веса моделей (`models/*.pt`) и датасеты автоматически доступны.

При необходимости добавьте дополнительные volume-примапы в `cv-app` (например, отдельный диск с видео).

## GPU

Compose-конфигурация не включает GPU по умолчанию. Чтобы передать GPU устройству, запустите:

```bash
docker compose -f infra/docker-compose.yml run --gpus all cv-app
```

или отредактируйте `docker-compose.yml`, добавив секцию `deploy.resources.reservations.devices` / `device_requests` (зависит от вашей версии Docker).

## Обновление зависимостей

После изменения `requirements.txt` выполните пересборку образа:

```bash
docker compose -f infra/docker-compose.yml build cv-app
```

Если нужно только пересобрать, но не запускать — остановите стек после успешной сборки.

## Частые сценарии

- **Только приложение** (используя внешнюю БД): установите `SKIP_DB_BOOTSTRAP=1` и `DATABASE_URL` на нужный хост, затем
  ```bash
  docker compose -f infra/docker-compose.yml up cv-app
  ```
- **Перезапустить пайплайн без пересборки**:
  ```bash
  docker compose -f infra/docker-compose.yml restart cv-app
  ```
- **Просмотр логов**:
  ```bash
  docker compose -f infra/docker-compose.yml logs -f cv-app
  ```

## Траблшутинг

- Если контейнер `cv-app` не стартует, проверьте переменные (`DATABASE_URL`, `APP_MODE`) и убедитесь, что PostgreSQL прошёл healthcheck.
- При ошибках импорта проверьте, что проект действительно смонтирован в `/workspace` (или переопределите `APP_ROOT` на используемый путь).
- Если пайплайн не видит видео/модели, убедитесь, что каталоги `data`, `datasets`, `models` присутствуют рядом с `infra/` на хосте и содержат ожидаемые файлы.
